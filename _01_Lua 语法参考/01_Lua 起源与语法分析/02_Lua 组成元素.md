### Lua 组成元素

---
- [1. 标记与注释](#1-标记与注释)
- [2. 关键字与保留字](#2-关键字与保留字)
	- [2.1 Lua 标准关键字](#21-lua-标准关键字)
	- [2.2 Lua 预留常用的保留字](#22-lua-预留常用的保留字)
- [3. 全局变量与局部变量](#3-全局变量与局部变量)
- [4. 类型声明](#4-类型声明)
	- [4.1 nil（空）](#41-nil空)
	- [4.2 boolean（布尔）](#42-boolean布尔)
	- [4.3 number（数值）](#43-number数值)
	- [4.4 string（字符串）](#44-string字符串)
		- [4.4.1 字符串常量](#441-字符串常量)
		- [4.4.2 获取字符串的长度](#442-获取字符串的长度)
		- [4.4.3 拼接字符串](#443-拼接字符串)
		- [4.4.4 转义字符](#444-转义字符)
		- [4.4.5 字符串中强制类型转换](#445-字符串中强制类型转换)
		- [4.4.6 字符串格式化](#446-字符串格式化)
	- [4.5 table（表）](#45-table表)
		- [4.5.1 表元素和表索引](#451-表元素和表索引)
		- [4.5.2 表构造器](#452-表构造器)
		- [4.5.3 表中列表的长度](#453-表中列表的长度)
		- [4.5.4 表的安全访问](#454-表的安全访问)
	- [4.6 function（函数）](#46-function函数)
		- [4.6.1 可变长参数函数](#461-可变长参数函数)
		- [4.6.2 函数尾调用](#462-函数尾调用)
		- [4.6.3 非全局函数](#463-非全局函数)
		- [4.6.3 闭包](#463-闭包)
		- [4.6.4 表函数](#464-表函数)
	- [4.7 thread（线程）](#47-thread线程)
	- [4.8 userdata（用户类型）](#48-userdata用户类型)
	- [4.9 弃元 \_](#49-弃元-_)

---
## 1. 标记与注释

> ***标记***

- Lua 标记（标识符）为程序中的变量、函数和标签提供名称，名称在拼写和大小写上必须与任何关键字都不同。标识符的首字符不可以是数字字符

```lua
  -- 有效标识符
	_Identifier
	Identifier
	Identifier123
```

> ***注释***

```lua
	--	单行注释

	--[[
		多行注释
	]]--

	--[[
		多行注释
	]]

	--[[
		多行注释
	--]]

	--[=[
		多行注释
	]=]--
```

---
## 2. 关键字与保留字
### 2.1 Lua 标准关键字

```lua
	local		--> 声明局部类型
	function	--> 函数类型声明符
	nil			--> 空

	and			-->	逻辑运算 与
	not			--> 逻辑运算 非
	or			--> 逻辑运算 或

	if			--> 条件语句 if 分支
	else		--> 条件语句 else 分支
	elseif		--> 条件语句 elseif 分支
	end			--> 程序块结束标志
	false		--> 布尔逻辑值 假
	true		--> 布尔逻辑值 真

	for			--> for 循环
	in			--> for 循环 in 表达式
	then		--> for 循环体
	while		--> while 循环
	do			-->	do 语句块
	repeat		-->	repeat 循环
	until		-->	repeat 循环 until 表达式

	break		--> 跳出循环
	goto		--> 跳转语句
	return		-->	返回语句
```

---
### 2.2 Lua 预留常用的保留字


---
## 3. 全局变量与局部变量

- Lua 在文件范围内，变量默认情况下被认为是全局的。仅被声明的变量其默认值为 ```nil```。可以使用 ```nil``` 值将一个不再使用的变量置空，Lua 会自动回收该变量占用的内存

```lua
	a			-- 变量声明，默认为 nil
	print(a)	--> nil
	a = 10; print(a);	--> 10
	a = nil		-- 置空，垃圾自动回收
```

> ***local 局部变量***

- 可以使用 ```local``` 限制变量为某个程序块的局部变量，仅在该程序块范围可见

```lua
str = "Hello"

f = function()
	local str = "World"		-- str 为函数块 f 的局部变量
	print(str)
end

f()				--> World
print(str) 		--> Hello
```

> 应该尽可能的使用局部变量

- 可以避免命名冲突
- 访问局部变量的速度比全局变量更快
- 常使用 ```local val = val``` 在局部程序块中保存全局变量的值，在使用时防止全局 ```val``` 在外部已经发生改变的情况

---
## 4. 类型声明

- Lua 语言是一种动态类型语言，不存在类型定义，变量值本身都带有自身的类型信息
- Lua 中有 8 个基本类型分别为：nil（空）、boolean（布尔）、number（数值）、string（字符串）、userdata（用户数据）、function（函数）、thread（线程） 和 table（表）

```lua
-- type 函数可以获取值的类型，函数的返回值不可丢弃
type(nil)		--> nil
type(true)		--> boolean
type(1234)		--> number
type("Hello")	--> string
type(io.stdin)	--> userdata
type(print)		--> function
type({})		--> table
type(type(X))	--> string
```

- userdata 类型允许把任意的 C 语言数据保存在 Lua 语言变量中。在 Lua 语言中，用户数据类型除了赋值和相等性测试外，没有其他预定义的操作

---
### 4.1 nil（空）

- nil 是仅有一个 ```nil``` 值的类型，在 Lua 中用来表示无效值。首次声明的变量未定义之前，其值为 ```nil```；而将 ```nil``` 赋值给其他变量，相当于将其删除

> nil 删除一个表元素

```lua
tab1 = { key1 = "val1", key2 = "val2", "val3" }
for k, v in pairs(tab1) do
    print(k .. " - " .. v)
end
--[[
	1 - val3
	key1 - val1
	key2 - val2
--]]
----------------------------------
tab1.key1 = nil		-- 删除 key1 键值对
for k, v in pairs(tab1) do
    print(k .. " - " .. v)
end
--[[
	1 - val3
	key2 - val2
--]]
```

---
### 4.2 boolean（布尔）

- boolean 类型具有两个值，```true``` 和 ```false```，用于表示条件测试的结果
- 在 Lua 中，boolean 并非是用于条件测试的唯一方式，任何非 ```nil``` 值和 ```true``` 表示为 ```true```，```false``` 和 ```nil``` 表示 ```false```

---
### 4.3 number（数值）

- 5.3 版本开始，Lua 的数值类型提供了 64 位 integer 整型和 64 位 double 双精度浮点类型（也可以编译 Lua 使用 32 位的整数和浮点数）
- 数值字面量可以使用科学计数法。具有十进制小数或者指数的数值会被当做浮点型值，否则会被当做整型值

```lua
n1 = 4		--> 整型 number
n2 = 0.4	--> 浮点型
n3 = 1.3e-2	--> 浮点型，科学计数法
n4 = 5E10	--> 浮点型，科学计数法
```

> 数值类型相等

- 整型和浮点型都是 number，算数值相同的整型值和浮点型值在 Lua 中是相等的

```lua
	1 == 1.0		--> true
	-3 == -3.0		--> true
	0.2e3 == 200 	--> true
```

> ***math.type()*** 可以用于区分数值类型

```lua
	print(math.type(1))		--> integer
	print(math.type(1.5))	--> float
```

> 十六进制浮点数

- 0x 作为前缀，用 p 和 P 代替 e 和 E，用 2 的幂代替 10 的幂（P 计数法）

```lua
num = 0xa.1fp10;
--[[
	a   ---- 10
	.1f ---- 1/16 + 15/256
	p10 ---- 2^10
]]--
0xa.1fp10 = (10 + 1/16 + 15/256) * 2^10 = 10364.0
```

- 使用 ```%a``` 格式转换说明符，进行十六进制浮点数格式化输出

```lua
	string.format("%a", 666)	--> 0x1.4dp+9
	string.format("%a", 0.1)	--> 0x1.999999999999ap-4
```

> 浮点型与整型之间的转换

- 可以将整型加上一个 0.0 浮点数将整数转换成浮点数
- 浮点数通过与 0 按位或运算，将浮点数转换成整型。强制转换成整型时，Lua 会检查浮点数的数值是否与整型值完全一致（其值在整型范围内，且小数部分不能超过 0，否则按位或运算会抛出异常）
- 对小数进行取整必须显式地调用取整函数

```lua
	12345 + 0.0 	--> 12345.0
	12345.0 | 0		--> 12345
	2^53		--> 9.007199254741e+15	(浮点型值)
	2^53 | 0	--> 9007199254740922	(整型值)
-- error
	3.2 | 0		--> 小数部分 > 0
	2^64 | 0	--> 超出范围
```

- 另外一种方式是利用库函数 ```math.tointeger```，```math.tointeger``` 方法在无法转换成整数时返回 ```nil```

```lua
-- math.tointeger
	math.tointeger(12345.0)	--> 12345
	math.tointeger(5.01)	--> nil
```

> 数值范围和溢出

- 标准 Lua 使用 64 位存储整数值，最大值为 $2^{63}-1$。数学库定义了整型类型的最大值和最小值，超过极值的运算会发生算术溢出，最高位产生的溢出将会被丢弃，运算结果发生回环。实际结果等于其补码的模
- 对于浮点值，双精度 64 位浮点数的范围在 $-10^{308}$ ~ $10 ^ {308}$。使用浮点数精确表示整数，其范围被限制在 $-2^{53}$ ~ $2^{53}$ 之间超过这个范围后，整型转换成浮点数之后会丢是精度

```lua
	-- 2^53 = 9007199254740922
	9007199254740921 + 0.0 == 9007199254740921 	--> true，浮点转换
	9007199254740922 + 0.0 == 9007199254740922 	--> true

	-- 超出浮点数精确表示整型数值的范围，转换成浮点数时，整型精度丢失
	9007199254740923 + 0.0 == 9007199254740923  --> false
```

---
### 4.4 string（字符串）

- Lua 中的字符串是一串字节组成的序列。Lua 中的字符串是不可变值，无法直接修改字符串中的某个字符，进行替换或者拼接等操作字符串时，Lua 会重新创建一个新的字符串的方式以达到修改的目的
- Lua 的字符串是自动内存管理对象，Lua 会负责字符串的分配和释放

---
#### 4.4.1 字符串常量

- 可以使用 ```"string"``` 或 ```'string'``` 一对双引号或单引号来声明字符串常量。它俩的区别在于，使用双引号声明的字符串中出现单引号时，单引号可以不用转义；使用单引号声明的字符串中出现双引号时，双引号可以不用转义

```lua
	a = "a line"
	b = 'another line'
```

> 行字符串

- ```[=[ ]=]``` 用于声明多行/长字符串，其中的转义序列不会被转义；等号的数目可以是 0 ~ 多个，前后的数目相等

```lua
str = [=[
	Hello
	World
]=]
```

----
#### 4.4.2 获取字符串的长度

- ```#``` 长度操作符可以获取字符串的长度。该操作符返回字符串占用的字节数，由于编码的不同，返回值可能和字符串中字符个数不同。例如中文单个字符占用 3 个字节

```lua
	a = "Hello"
	print(#a)	--> 5
```

---
#### 4.4.3 拼接字符串

- ```..``` 连接操作符用来字符串拼接并组合成一个新的字符串，第二个操作数可以是 number，Lua 会预先将 number 转换成字符串

```lua
	"Hello ".."World"	--> Hello World
	"Result is "..3		--> Result is 3
```

---
#### 4.4.4 转义字符

```lua
	\a		--> 响铃
	\b		-->	退格
	\f		--> 换页
	\n		--> 换行
	\r		--> 回车
	\t		--> 水平制表符
	\v		--> 垂直制表符
	\\		--> 反斜杠
	\'		--> 单引号
	\"		--> 双引号
	\0		--> 空字符
	\ddd,\xhh, \u{h…h}	--> 声明字符，ddd 3个十进制数字序列，h 表示十六进制数
	\[,\]	--> 方括号
```

- ```\z```：忽略其后的字符直至遇到空白字符开始，继续忽略中间的空白字符和 EOF 直至遇到第一个非空白字符（空白字符值得是文本输入下的空白字符，不是转义后的空白字符）

```lua
	"12345\z    6"	--> 123456

	"12345\z
	678"		--> 12345678

	"123\z     \r678"
	--[[
		123
		678
	]]
```

---
#### 4.4.5 字符串中强制类型转换

- Lua 在运行时提供了数值和字符串之间的自动转换。针对字符串的算术操作时，Lua 会预先尝试将字符串转换成数值类型
- 其他的运算符（如比较）不会对字符串或数值进行强制类型转换

```lua
	math.cos("0")		--> 1.0
	print(1 + "2")		--> 3
	print(1 + "0x1")	--> 2
```

- 在需要字符串的地方出现了数值类型，Lua 会把数值转换成字符串
- ```..``` 拼接两个数值类型的操作数时为避免编译时歧义，操作符要与第一个操作数之间间隔一个空格，避免被认为是小数点

```lua
	print(1 .. 2)		--> 12
	print(1 ..234)		--> 1234
```

> 显式转换为数值

- ```tonumber(str [,n])```，默认行为是转换成十进制数值，失败时返回 nil；传入 n 用于指定待转换字符串的进制，最大可以指明使用二进制到三十六进制之间的任何进制

```lua
	tonumber("  -15")		--> -15
	tonumber("10e4")	--> 100000.0
	tonumber("fff", 16)	--> 4095
```

---
#### 4.4.6 字符串格式化

- Lua 提供了**string.format()**函数来生成具有特定格式的字符串。由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。这个函数的格式很像 C 语言中的 ```printf()```


|符号|含义|
|:----:|:----|
|%c|接受一个数字, 并将其转化为ASCII码表中对应的字符|
|%a+|a表示接受一个字母，+表示可以接受多个字母，就是接受单词的意思|
|%d, %i|接受一个数字并将其转化为有符号的整数格式|
|%o|接受一个数字并将其转化为八进制数格式|
|%u|接受一个数字并将其转化为无符号整数格式|
|%x|接受一个数字并将其转化为十六进制数格式, 使用小写字母|
|%X|接受一个数字并将其转化为十六进制数格式, 使用大写字母|
|%e|接受一个数字并将其转化为科学记数法格式, 使用小写字母e|
|%E|接受一个数字并将其转化为科学记数法格式, 使用大写字母E|
|%f|接受一个数字并将其转化为浮点数格式|
|%g(%G)|接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式|
|%q|接受一个字符串并将其转化为可安全被Lua编译器读入的格式，"......"|
|%s|接受一个字符串并按照给定的参数格式化该字符串|
|以上参数基础上|可以在%号后添加参数.|
|+|一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.|
|0|一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格|
|-|在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐|
|宽度数值|指定宽度|
|"%.4f",1/3|小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位.|

```lua
string1 = "Lua"
string2 = "Tutorial"
number1 = 10
number2 = 20
-- 基本字符串格式化
print(string.format("基本格式化 %s %s",string1,string2))
--> 基本格式化 Lua Tutorial

-- 日期格式化
date = 2; month = 1; year = 2014
print(string.format("日期格式化 %02d/%02d/%03d", date, month, year))
--> 日期格式化 02/01/2014

-- 当 0 不写时只写一个表示宽度的数字时，会用空格替换掉 0 的占位，填入的字符会右对齐补齐占位
string.format("%7d", "str")
--> (     str)，输出的字符串有10个宽度，其中前五个位空格
--> 可以用 (-) 放在 % 后面表示设置宽度的同时，字符串占位遵循左对齐

-- 十进制格式化
print(string.format("%.4f",1/3))
--> 0.3333，.4f表示转化为小数时保留四位小数
```

---
### 4.5 table（表）

- 表（table）是 Lua 中唯一的数据结构机制，例如 math 数学库的本质是一个表结构
- Lua 中的表本质上是一种辅助数组，不仅可以用数值作为索引，也可以使用字符串或其他任意类型的值（除 ```nil```）作为索引
- 表是一种动态分配的对象，程序只能操作指向表的引用，Lua 不会进行隐藏的拷贝或创建新的表。变量和表之间是引用关系
- 一个表失去所有引用时，垃圾收集器会删除这个表
- Lua 使用表结构用来存储全局变量的，被称为 ```_G``` 大 G 表
- table 可以用来表示数组、列表、符号表、集合、记录、图形、树等数据结构

```lua
_math = math	--> _math 和 math 引用同一张表
_math.abs = 1;	--> abs 被重定义

if (_math.abs == math.abs) then
	print("Hello")		--> Hello
end

print(math.abs(-10))	-- Error: attempt to call a number value
```

> 构造一个表结构

```lua
a = {}			--> 创建一个表
key1 = "K1"
a[key1] = 10	--> 新元素 <"K1", 10>
a[1] = "Great"	--> 新元素 <1, "Great">
a.num = 999		--> 新元素 <"num", 999>
-- 元素访问
print(a["K1"])	--> 10
a[key1] = a[key1] * 2 	--> 20
key1 = 1
print(a[key1])	--> "Great"
```

> 构造器构造法

- Lua 中的表可以被用作数组，或是一个结构体

```lua
b = {
	Key1 = "K1",
	["Key2"] = "K2",
	[1] = 1,
	[2] = 2
}
```

---
#### 4.5.1 表元素和表索引

- 表索引可以是除 ```nil``` 和 ```NaN``` 外的任何值，与值 ```nil``` 关联的任何键都不被视为表的一部分。利用这个特性将表元素置为 ```nil``` 等于将其从表中移除

> 表元素访问

```lua
b = {
	Key1 = "K1",
	["Key2"] = "K2",
	[1] = 1,
	[2] = 2
}

-- b.Key1、b.Key2、b[1]...
b.Key1  == b["Key1"]
b[1] ~= b["1"]	--> b["1"] = nil
```

> 数值类型充当表索引时

- 当 Lua 认为一个浮点值和一个整数相等时，表认为它们作为索引时指向的是同一个元素

```lua
a = {}
a[2.0] = 10
a[2.1] = 20

print(a[2.0], a[2], a[2.1])		--> 10	10	20

a[1.000000000000000001] = 30
print(a[1])			--> 30；由于精度丢失问题，Lua 判定这两个数值相等

```

---
#### 4.5.2 表构造器

- 表构造器用来创建并初始化表的表达式，对于列表式表元素的声明，Lua 会自动从 1 开始为每个列表元素创建索引关联
- 记录式构造用于显式地指定表元素的索引值

> 列表式初始化表

```lua
day = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
-- 索引从 1 开始为每个列表元素建立索引关联

print(day[4])	--> Wednesday
```

> 记录式初始化表

```lua
a = {x = 1, y = 2}
-- 等价于
a = {}
a.x = 1
a["y"] = 2
```

> 显式索引构造列表

- 列表的索引可以显式声明，在计算列表的长度时会忽略小于 1 的索引
- 显式声明的列表，其长度列表是否存在连续 ```nil``` 值的影响。当值中出现连续 ```nil``` 值时，列表的长度不会再增长，它的最大值为开始出现连续 ```nil``` 的位置前导位置元素的索引值

```lua
arr = {[1]=1,[2]=2,[4]=4,[5]=5,[7]=7,[9]=9}
-- #arr = 5
Arr = {[1]=1,[2]=2,[4]=4,[5]=5,[7]=7,[8]=8}
-- #Arr = 8
```

---
#### 4.5.3 表中列表的长度

- 一个表既可以表示一组列表，也可以是一个记录，也可以是键值对与列表组合。```#``` 可以用来获取表的列表长度
- 列表末端的 ```nil``` 值会被忽略而不计入总长，列表内部的 ```nil``` 值使得该列表存在空洞，对于中间存在空洞的列表而言，列表长度操作符是不可靠的。

```lua
a = {1,2,3,4,5,6}		--> #a = 6
a = {1,2,3,nil,nil}		--> #a = 3
a = {1,nil,nil,nil,nil,2}	--> #a = 6
a = {}
a[1] = 1; a[2] = 2; a[4] = 4	--> #a = 4, 中间存在空洞
```

---
#### 4.5.4 表的安全访问

- 当需要确认指定的库中是否存在某个函数时，可以使用安全访问操作。Lua 中没有提供安全访问操作符（例如 C# 的 ```?.```），但可以模拟为

```lua
E = {}
zip = (((company or E).director or E).address or E).zipcode
```

---
### 4.6 function（函数）

- 在 Lua 中，函数是被看作是 “第一类值（First-Class Value）”，所有的函数都是匿名的，函数定义实质上就是创建类型为 ```function``` 的值并赋值给变量

> Lua 中函数定义的两种语法格式

```lua
function Add(a)
	local sum = 0
	for i = 1, #a do
		sum = sum + a[i]
	end
	return sum
end
-------------------------------
Add = function(a)
	local sum = 0
	for i = 1, #a do
		sum = sum + a[i]
	end
	return sum
end
```

> 匿名函数写法

```lua
(function()
	<some-code>
end)()
--------------------
table.sort(network,
	function(a, b)
		return (a.name > b.name)
	end)
```

> 函数调用

- 一般情况下，函数调用时需要一对括号 ```()``` 把参数列表括起来，无参时也需要一对空括号；但当函数只有一个参数且该参数是字符串常量或表构造器时，括号是可选的

```lua
print "Hello"   -- print("Hello")
type{}			-- type({})
```

- 调用函数时使用的参数个数可以与定义函数时使用的参数个数不一致。Lua 会通过抛弃多余参数或用 ```nil``` 补足的方式来调整参数的个数

> 函数返回

- 函数 ```return``` 可以返回多个结果，可以使用多重赋值的方式接收函数的返回结果
- 在**多重赋值**中，当函数返回值的个数不够多时，Lua 会使用 ```nil``` 补全缺失的值；个数过多时也会丢弃多余的返回值
- 只有当函数调用是一系列表达式中的最后（或唯一）一个表达式时，才能返回多值结果，否则值会返回一个结果

```lua
function Foo(a)
	return a, a ^ 2, a ^ 3
end

a,b,c = Foo(2)
```

- 当一个函数调用是另一个函数的最后一个或唯一一个实参时，那该实参函数的返回值都会作为实参传给第二个函数

```lua
function foo(a,b)
	print(a+b)
end
function boo(a)
	return a, a^2
end

foo(boo(2))		--> foo(2,4) --> 6
```

> 利用表完整接收函数的多重值返回

- 表构造器会完整地接收函数调用的所有返回值，且不会调整返回值的个数

```lua
function Foo(a)
	return a, a^2, a^3
end

t = {Foo(2)} 	--> t = {2,4,8}
```

> 多重赋值

- 可以利用表达式或函数返回多重值的特性，对多个变量赋值

```lua
a,b = Foo(X)
a,b,c = table.unpack(...)
```

- 交换两个变量的值

```lua
a,b = b,a
t[a],t[b] = t[b],t[a]
```

---
#### 4.6.1 可变长参数函数

- Lua 中函数支持可变长参数，```...``` 作为参数表示该函数的参数数目不固定，函数内部会把 ```...``` 所有参数收集起来，可以把它们组合成一个格外参数表 ```{...}```，也可以利用多重赋值按顺序提取
- 函数可以有最多一个可变长参数，且需要放在参数列表的最后一位。变长数组中可能会传入无效 ```nil```，Lua 中提供 ```table.pack``` 检测参数中是否有 ```nil```

```lua
function Foo(a, ...)
	local t = { ... }
	if (#t > 0) then
		for i = 1, #t do
			print(t[i])
		end
	end
	print("end :" .. a)
end
Foo(1, 2, 3, 4, 5, 6)
```

> select 函数

- 另一种遍历函数可变长参数的方法是利用函数 ```select(n,...)```，n 为数值时，返回第 n 个参数后的所有参数；n 是字符串 ```"#"``` 时，返回额外参数的总数

```lua
-- 打印奇数位的元素
function Foo(...)
	local len = select("#", ...)
	local i = 1
	local a = 0
	while i <= len do
		a = select(i, ...)
		print(a)
		i = i + 2
	end
end
Foo(1,2,3,4,5,6,7,8)	-- 1 3 5 7
```

---
#### 4.6.2 函数尾调用

- 当一个函数的最后一步是调用另一个函数而没有进行其他工作时，就形成了尾调用。

```lua
function f(x)
	x = x + 1
	return g(x)
end
```

- 当函数 f 调用完函数 g 之后，f 不需要进行其他的工作。此时当 g 返回时，程序的执行路径会之间返回到调用 f 的位置，这使得在进行尾调用时不使用额外的栈空间
- 由于尾调用不会使用栈空间，所以一个程序中能够嵌套的尾调用的数目是无限的
- 在 Lua 中，只有形如 ```return func(args)``` 的调用才是尾调用

---
#### 4.6.3 非全局函数

> 声明局部函数

```lua
local function f(params)
	<some-code>
end
----------------------------
local function fact(n)
	if n == 0 then return 1
	else return n * fact(n - 1)
	end
end
```

> 另一种声明方式

```lua
local f = function(params)
	<some-code>
end
```

- 在定义局部递归函数时，这种方式极易出现错误，可以尝试先定义局部变量再定义函数的方式避免这个问题

```lua
local f
f = function(params)
	<some-code>
end
```

---
#### 4.6.3 闭包

- 闭包原则：**闭包就是能够读取其他函数内部变量的函数**。只有函数内部的子函数才能读取**局部变量**，所以闭包可以理解成 “**定义在函数内部的函数**”。在本质上，**闭包是将函数内部和函数外部连接起来的桥梁**

- 从技术上讲，Lua 语言中只有闭包而没有函数，函数本身只是闭包的一种原型。利用闭包可以保存外部函数退出前的状态，而不用占用额外的资源

```lua
function Counter(count)
	return function ()
		count = count +1
		return count
	end
end

c1 = Counter(10)	-- 从 10 开始计数
print(c1())		--> 11
print(c1())		--> 12
print(c1())		--> 13
```

> 预定义函数

- 通常，当重新定义一个函数时，需要在新的实现中调用原来的那个函数。例如创建一个安全的运行时环境 ```io.open```，限制该函数的安全运行环境

```lua
do
	local oldOpen = io.open
	local function access_OK(filename, mode)
		-- check access --
		if (file.Exist(filename)) then
			return true
		end
		return false
	end
	-- 旧版的 io 访问只能通过新的 io 访问
	io.open = function(filename, mode)
		if access_OK(filename, mode) then
			return oldOpen(filename, mode)
		end
		return nil, "access denied"
	end
end
```

---
#### 4.6.4 表函数

- 表调用自身的表函数成员时，可以通过两种方式调用：```table.fun()``` 或 ```table:fun()```。区别在于第二种方式默认将表自身作为第一个参数传递给表函数
- 表函数是一种非全局函数

```lua
t = {1,2,3,4,5,6}
t.Traverse = function (t)
	for i =1,#t do
		print(t[i])
	end
end
t:Traverse()	-- 传递自身作为首位参数到表函数中
```

- 外部声明表函数的时候可以通过 ```:``` 声明，表示默认将表自身作为第一个参数传入函数

```lua
T.func = function(T)
-- 等价于
function T:Traverse()
```

---
### 4.7 thread（线程）

- thread 类型表示独立的执行线程，它用于实现协程。Lua 线程与操作系统线程无关，并且在所有系统上都支持协程
- 在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西
- 线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停


---
### 4.8 userdata（用户类型）

- userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用
- 不能在 Lua 中创建或修改用户数据值，只能通过 C API。这保证了宿主程序和 C 库拥有的数据的完整性

---
### 4.9 弃元 _

- ```_``` 表示弃元，无法直接获取弃元的物理地址，也无法获取弃元的值。弃元一般用于占位或放弃赋值，常用于函数参数列表或多重赋值

```lua
_, a = fun()		-- 表示放弃函数第一个返回值
function foo(_, v)	-- 表示放弃第一个参数传递
```

---